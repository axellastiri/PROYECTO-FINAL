import machine
import network
import utime
import usocket
import _thread
import ujson

# ========== Configuración / Globals ==========
UART_ID = 2
UART_BAUD = 115200
UART_TX_PIN = 17
UART_RX_PIN = 16

nic = None
s_web = None

uart = None
lkUART = _thread.allocate_lock()

# Buffer de líneas entrantes desde RP2040
incoming_lines = []
lkLines = _thread.allocate_lock()

# Buffer para almacenar puntos calculados
calculated_points = []
lkPoints = _thread.allocate_lock()

VERBOSE = True   # True para debug en REPL
MAX_DEBUG_LINES = 200

# =============================================
# Inicialización
# =============================================
def setupUART():
    global uart
    uart = machine.UART(UART_ID, baudrate=UART_BAUD, tx=UART_TX_PIN, rx=UART_RX_PIN, timeout=10, timeout_char=10)
    print("UART initialized")

def setupWiFi():
    global nic
    nic = network.WLAN(network.AP_IF)
    nic.active(False)
    nic.config(ssid="Sensor", security=network.AUTH_WPA2_PSK, key="12345678")
    nic.active(True)
    nic.ifconfig(("192.168.1.1", "255.255.255.0", "192.168.1.1", "192.168.1.1"))
    network.hostname("Sensor")
    print("WiFi AP configured")

def setupSockets():
    global s_web
    while not nic.active():
        utime.sleep_ms(100)
    s_web = usocket.socket(usocket.AF_INET, usocket.SOCK_STREAM)
    s_web.setsockopt(usocket.SOL_SOCKET, usocket.SO_REUSEADDR, 1)
    ip = nic.ifconfig()[0]
    s_web.bind((ip, 80))
    s_web.listen(5)
    print("Listening on", ip, ":80")

# =============================================
# Handshake (PING -> expect PONG)
# =============================================
def do_handshake(retries=6, per_try_timeout_ms=2000):
    print("Checking RP2040 communication (PING -> PONG)...")
    for attempt in range(retries):
        with lkUART:
            uart.write(b"PING\n")
        t_start = utime.ticks_ms()
        while utime.ticks_diff(utime.ticks_ms(), t_start) < per_try_timeout_ms:
            if uart.any():
                raw = uart.readline()
                if not raw:
                    utime.sleep_ms(10)
                    continue
                try:
                    s = raw.decode("utf-8", "ignore").strip()
                except:
                    s = str(raw)
                print("UART received:", s)
                if "PONG" in s:
                    print("RP2040 communication OK")
                    return True
            utime.sleep_ms(10)
        print("Retrying PING...", attempt+1)
    return False

# =============================================
# Reader thread: lee UART continuamente y guarda líneas
# =============================================
def uart_reader_thread(_):
    global incoming_lines, calculated_points
    print("UART reader thread started")
    line_buffer = ""  # Buffer para líneas incompletas
    
    while True:
        try:
            if uart.any():
                # Leer datos disponibles
                chunk = uart.read(uart.any())
                if chunk:
                    try:
                        text = chunk.decode("utf-8", "ignore")
                        line_buffer += text
                        
                        # Procesar líneas completas
                        while "\n" in line_buffer:
                            line, line_buffer = line_buffer.split("\n", 1)
                            line = line.strip()
                            
                            if not line:
                                continue
                            
                            # Procesar líneas especiales de puntos
                            if line.startswith("PUNTO:"):
                                # Formato: PUNTO:index:x,y1,y2
                                try:
                                    # Remover "PUNTO:"
                                    data = line[6:]
                                    # Separar índice del resto
                                    if ":" in data:
                                        idx_str, values = data.split(":", 1)
                                        idx = int(idx_str)
                                        parts = values.split(",")
                                    else:
                                        # Formato anterior sin índice
                                        parts = data.split(",")
                                        idx = -1
                                    
                                    if len(parts) == 3:
                                        x = float(parts[0])
                                        y1 = float(parts[1])
                                        y2 = float(parts[2])
                                        with lkPoints:
                                            calculated_points.append({
                                                "idx": idx,
                                                "x": x, 
                                                "y1": y1, 
                                                "y2": y2
                                            })
                                        if VERBOSE:
                                            print("PUNTO almacenado: idx={} x={:.4f}".format(idx, x))
                                except Exception as e:
                                    print("Error parsing PUNTO:", e, "Line:", line)
                            
                            # Guardar línea en buffer general
                            with lkLines:
                                incoming_lines.append(line)
                                if len(incoming_lines) > 2000:
                                    incoming_lines = incoming_lines[-1000:]
                            
                            if VERBOSE and not line.startswith("PUNTO:"):
                                print("LINE <-", line)
                                
                    except Exception as e:
                        print("Error decoding chunk:", e)
        except Exception as e:
            print("UART reader error:", e)
        utime.sleep_ms(10)  # Aumentado para dar más tiempo al procesamiento

# =============================================
# Esperar tokens
# =============================================
def wait_for_tokens(expected_tokens, timeout_ms=180000):
    found = {}
    start_time = utime.ticks_ms()
    while utime.ticks_diff(utime.ticks_ms(), start_time) < timeout_ms:
        with lkLines:
            for ln in incoming_lines:
                for tok in expected_tokens:
                    if tok in ln and tok not in found:
                        found[tok] = ln
        all_found = True
        for tok in expected_tokens:
            if tok not in found:
                all_found = False
                break
        if all_found:
            return found
        utime.sleep_ms(10)
    return found

def drain_until_token(token, timeout_ms=2000):
    collected = []
    start_time = utime.ticks_ms()
    while utime.ticks_diff(utime.ticks_ms(), start_time) < timeout_ms:
        with lkLines:
            while incoming_lines:
                ln = incoming_lines.pop(0)
                collected.append(ln)
                if token in ln:
                    return "\n".join(collected)
        utime.sleep_ms(10)
    return "\n".join(collected)

# =============================================
# Enviar solicitud sinc
# =============================================
def send_sinc_request(n, p, timeout_ms=180000):
    # Limpiar buffer de puntos antes de nueva solicitud
    with lkPoints:
        calculated_points.clear()
    
    req = "sinc:{},{}\n".format(n, p)
    with lkUART:
        uart.write(req.encode())
    print("UART =>", req.strip())

    # Esperar tokens
    expected = ["INICIA CALCULO", "T1:", "T2:", "TERMINADO"]
    found = wait_for_tokens(expected, timeout_ms=timeout_ms)

    if "TERMINADO" in found:
        resp = drain_until_token("TERMINADO", timeout_ms=2000)
    else:
        with lkLines:
            resp = "\n".join(list(incoming_lines))
            incoming_lines.clear()
    return resp

# =============================================
# Util: parse URI params
# =============================================
def fetch_uri_params(sreq):
    up = {}
    qmpos = sreq.find("?")
    if qmpos == -1:
        return up
    parts = sreq[qmpos+1:].split("&")
    for p in parts:
        pparts = p.split("=", 1)
        key = pparts[0]
        value = pparts[1] if len(pparts) > 1 else ""
        up[key] = value
    return up

# =============================================
# Página HTML
# =============================================
def webpage():
    html = """HTTP/1.1 200 OK
Content-Type: text/html

<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>Sinc Calculator</title>
<style>
body{background:linear-gradient(180deg,rgba(2,0,36,1)0%,rgba(9,9,121,1)35%,rgba(0,212,255,1)100%);
font-family:Tahoma,sans-serif;color:#000;margin:0;padding:20px;}
.container{max-width:1200px;margin:auto;padding:20px;background:#f8f8f8;border-radius:12px;box-shadow:0 4px 12px rgba(0,0,0,0.1);}
h1{text-align:center;margin-top:0;}
.controls{display:flex;gap:10px;align-items:center;justify-content:center;margin-bottom:10px;flex-wrap:wrap;}
input{width:6em;padding:6px;border-radius:6px;border:1px solid #ccc;}
button{padding:8px 12px;border-radius:8px;border:none;background:#008CBA;color:white;cursor:pointer;}
button:hover{background:#005F7A;}
table{border-collapse:collapse;width:100%;margin-top:12px;}
th,td{border:1px solid #aaa;padding:6px;text-align:center;font-size:0.9em;}
th{background:#eee;font-weight:bold;}
.status{margin-top:10px;text-align:center;font-weight:bold;}
.small{font-size:0.9em;color:#444;}
.section{margin-top:20px;}
.table-container{max-height:400px;overflow-y:auto;margin-top:10px;}
.chart-container{position:relative;height:400px;margin-top:20px;background:white;padding:15px;border-radius:8px;box-shadow:0 2px 8px rgba(0,0,0,0.1);}
canvas{width:100%!important;height:100%!important;}
.grid-layout{display:grid;grid-template-columns:1fr 1fr;gap:20px;margin-top:20px;}
@media (max-width: 768px){.grid-layout{grid-template-columns:1fr;}}
</style>
</head>
<body>
<div class="container">
<h1>Sinc Calculator</h1>
<div class="controls">
<label class="small">Terms (10-1000): <input id="terms" type="number" value="20" min="10" max="1000"></label>
<label class="small">Points (10-300): <input id="points" type="number" value="50" min="10" max="300"></label>
<button onclick="calculate();">Calculate</button>
</div>
<div class="status" id="statusArea"></div>

<div class="section">
<h2>Times (ms)</h2>
<table>
<thead><tr><th>1 Core</th><th>2 Cores</th><th>Difference</th></tr></thead>
<tbody id="timesTable"><tr><td colspan="3">No data</td></tr></tbody>
</table>
</div>

<div class="section">
<h2>Sinc Function Graph</h2>
<div class="chart-container">
<canvas id="sincChart"></canvas>
</div>
</div>

<div class="grid-layout">
<div class="section">
<h2>Calculated Values</h2>
<div class="table-container">
<table>
<thead><tr><th>x</th><th>y (1 Core)</th><th>y (2 Cores)</th><th>Difference</th></tr></thead>
<tbody id="valuesTable"><tr><td colspan="4">No data</td></tr></tbody>
</table>
</div>
</div>

<div class="section">
<h2>Graph Controls</h2>
<div style="background:white;padding:15px;border-radius:8px;">
<label style="display:block;margin-bottom:10px;">
<input type="checkbox" id="show1Core" checked onchange="toggleDataset(0)">
Show 1 Core Results
</label>
<label style="display:block;margin-bottom:10px;">
<input type="checkbox" id="show2Cores" checked onchange="toggleDataset(1)">
Show 2 Cores Results
</label>
<label style="display:block;margin-bottom:10px;">
<input type="checkbox" id="showPoints" checked onchange="togglePoints()">
Show Data Points
</label>
<p style="font-size:0.85em;color:#666;margin-top:15px;line-height:1.4;">
<strong>Note:</strong> The graph shows the complete symmetric sinc(x) function by reflecting the calculated values across the Y-axis.
</p>
</div>
</div>
</div>

<script>
let chartData = {data1Core: [], data2Cores: []};
let chartSettings = {show1Core: true, show2Cores: true, showPoints: true};

function drawChart(){
    const canvas = document.getElementById('sincChart');
    if(!canvas) return;
    
    const ctx = canvas.getContext('2d');
    const rect = canvas.parentElement.getBoundingClientRect();
    
    // Configurar tamaño del canvas
    canvas.width = rect.width - 30;
    canvas.height = rect.height - 30;
    
    const width = canvas.width;
    const height = canvas.height;
    
    // Márgenes
    const margin = {top: 40, right: 30, bottom: 50, left: 70};
    const plotWidth = width - margin.left - margin.right;
    const plotHeight = height - margin.top - margin.bottom;
    
    // Limpiar canvas
    ctx.fillStyle = 'white';
    ctx.fillRect(0, 0, width, height);
    
    if(chartData.data1Core.length === 0 && chartData.data2Cores.length === 0){
        ctx.fillStyle = '#666';
        ctx.font = '16px Tahoma';
        ctx.textAlign = 'center';
        ctx.fillText('No data available', width/2, height/2);
        return;
    }
    
    // Encontrar rangos de datos
    let allData = [];
    if(chartSettings.show1Core) allData = allData.concat(chartData.data1Core);
    if(chartSettings.show2Cores) allData = allData.concat(chartData.data2Cores);
    
    if(allData.length === 0){
        ctx.fillStyle = '#666';
        ctx.font = '16px Tahoma';
        ctx.textAlign = 'center';
        ctx.fillText('Select at least one dataset', width/2, height/2);
        return;
    }
    
    const xMin = Math.min(...allData.map(p => p.x));
    const xMax = Math.max(...allData.map(p => p.x));
    const yMin = Math.min(...allData.map(p => p.y));
    const yMax = Math.max(...allData.map(p => p.y));
    
    const xRange = xMax - xMin || 1;
    const yRange = yMax - yMin || 1;
    
    // Función para mapear coordenadas
    function mapX(x){ return margin.left + ((x - xMin) / xRange) * plotWidth; }
    function mapY(y){ return margin.top + plotHeight - ((y - yMin) / yRange) * plotHeight; }
    
    // Dibujar ejes
    ctx.strokeStyle = '#333';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(margin.left, margin.top);
    ctx.lineTo(margin.left, margin.top + plotHeight);
    ctx.lineTo(margin.left + plotWidth, margin.top + plotHeight);
    ctx.stroke();
    
    // Etiquetas de ejes
    ctx.fillStyle = '#000';
    ctx.font = 'bold 14px Tahoma';
    ctx.textAlign = 'center';
    ctx.fillText('x', margin.left + plotWidth/2, height - 10);
    
    ctx.save();
    ctx.translate(15, margin.top + plotHeight/2);
    ctx.rotate(-Math.PI/2);
    ctx.fillText('sinc(x)', 0, 0);
    ctx.restore();
    
    // Marcas del eje X
    ctx.fillStyle = '#666';
    ctx.font = '11px Tahoma';
    ctx.textAlign = 'center';
    for(let i = 0; i <= 5; i++){
        const x = xMin + (xRange * i / 5);
        const px = mapX(x);
        ctx.beginPath();
        ctx.moveTo(px, margin.top + plotHeight);
        ctx.lineTo(px, margin.top + plotHeight + 5);
        ctx.stroke();
        ctx.fillText(x.toFixed(2), px, margin.top + plotHeight + 20);
    }
    
    // Marcas del eje Y
    ctx.textAlign = 'right';
    for(let i = 0; i <= 5; i++){
        const y = yMin + (yRange * i / 5);
        const py = mapY(y);
        ctx.beginPath();
        ctx.moveTo(margin.left - 5, py);
        ctx.lineTo(margin.left, py);
        ctx.stroke();
        ctx.fillText(y.toExponential(1), margin.left - 10, py + 4);
    }
    
    // Dibujar grid
    ctx.strokeStyle = '#e0e0e0';
    ctx.lineWidth = 1;
    for(let i = 1; i < 5; i++){
        const y = yMin + (yRange * i / 5);
        const py = mapY(y);
        ctx.beginPath();
        ctx.moveTo(margin.left, py);
        ctx.lineTo(margin.left + plotWidth, py);
        ctx.stroke();
    }
    
    // Dibujar datos 1 Core
    if(chartSettings.show1Core && chartData.data1Core.length > 0){
        ctx.strokeStyle = 'rgb(75, 192, 192)';
        ctx.fillStyle = 'rgb(75, 192, 192)';
        ctx.lineWidth = 2;
        
        ctx.beginPath();
        for(let i = 0; i < chartData.data1Core.length; i++){
            const p = chartData.data1Core[i];
            const px = mapX(p.x);
            const py = mapY(p.y);
            if(i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
        }
        ctx.stroke();
        
        // Puntos
        if(chartSettings.showPoints){
            for(let i = 0; i < chartData.data1Core.length; i++){
                const p = chartData.data1Core[i];
                const px = mapX(p.x);
                const py = mapY(p.y);
                ctx.beginPath();
                ctx.arc(px, py, 3, 0, 2 * Math.PI);
                ctx.fill();
            }
        }
    }
    
    // Dibujar datos 2 Cores
    if(chartSettings.show2Cores && chartData.data2Cores.length > 0){
        ctx.strokeStyle = 'rgb(255, 99, 132)';
        ctx.fillStyle = 'rgb(255, 99, 132)';
        ctx.lineWidth = 2;
        
        ctx.beginPath();
        for(let i = 0; i < chartData.data2Cores.length; i++){
            const p = chartData.data2Cores[i];
            const px = mapX(p.x);
            const py = mapY(p.y);
            if(i === 0) ctx.moveTo(px, py);
            else ctx.lineTo(px, py);
        }
        ctx.stroke();
        
        // Puntos
        if(chartSettings.showPoints){
            for(let i = 0; i < chartData.data2Cores.length; i++){
                const p = chartData.data2Cores[i];
                const px = mapX(p.x);
                const py = mapY(p.y);
                ctx.beginPath();
                ctx.arc(px, py, 3, 0, 2 * Math.PI);
                ctx.fill();
            }
        }
    }
    
    // Leyenda
    ctx.font = '12px Tahoma';
    let legendY = margin.top;
    
    if(chartSettings.show1Core){
        ctx.fillStyle = 'rgb(75, 192, 192)';
        ctx.fillRect(margin.left + 10, legendY, 20, 12);
        ctx.fillStyle = '#000';
        ctx.textAlign = 'left';
        ctx.fillText('1 Core', margin.left + 35, legendY + 10);
        legendY += 20;
    }
    
    if(chartSettings.show2Cores){
        ctx.fillStyle = 'rgb(255, 99, 132)';
        ctx.fillRect(margin.left + 10, legendY, 20, 12);
        ctx.fillStyle = '#000';
        ctx.textAlign = 'left';
        ctx.fillText('2 Cores', margin.left + 35, legendY + 10);
    }
}

function toggleDataset(index){
    if(index === 0) chartSettings.show1Core = !chartSettings.show1Core;
    else chartSettings.show2Cores = !chartSettings.show2Cores;
    drawChart();
}

function togglePoints(){
    chartSettings.showPoints = document.getElementById('showPoints').checked;
    drawChart();
}

function updateChart(data){
    chartData.data1Core = [];
    chartData.data2Cores = [];
    
    // Crear puntos reflejados (negativos) primero, en orden inverso
    for(let i = data.length - 1; i >= 0; i--){
        let point = data[i];
        if(point.x > 0){ // Solo reflejar puntos positivos
            chartData.data1Core.push({x: -point.x, y: point.y1});
            chartData.data2Cores.push({x: -point.x, y: point.y2});
        }
    }
    
    // Agregar puntos originales
    for(let i = 0; i < data.length; i++){
        let point = data[i];
        chartData.data1Core.push({x: point.x, y: point.y1});
        chartData.data2Cores.push({x: point.x, y: point.y2});
    }
    
    drawChart();
}

function parseTimesFromText(text){
    let lines = text.split("\\n");
    let t1 = null, t2 = null;
    for(let ln of lines){
        ln = ln.trim();
        if(ln.startsWith("T1:")) {
            let v = ln.substring(3).trim();
            if(v) t1 = parseInt(v);
        } else if(ln.startsWith("T2:")) {
            let v = ln.substring(3).trim();
            if(v) t2 = parseInt(v);
        }
    }
    return {t1:t1, t2:t2};
}

function calculate(){
    let n = parseInt(document.getElementById("terms").value);
    let p = parseInt(document.getElementById("points").value);
    let status = document.getElementById("statusArea");
    if(isNaN(n) || isNaN(p)) { status.textContent = "Ingresa valores válidos"; return; }
    if(n < 10 || n > 1000 || p < 10 || p > 300) { status.textContent = "Valores fuera de rango"; return; }

    status.textContent = "Calculando... por favor espere";
    document.getElementById("timesTable").innerHTML = "<tr><td colspan='3'>Esperando respuesta...</td></tr>";
    document.getElementById("valuesTable").innerHTML = "<tr><td colspan='4'>Esperando datos...</td></tr>";

    let expectedPoints = p; // Guardamos cuántos puntos esperamos

    let xhr = new XMLHttpRequest();
    xhr.open("GET", "/sinc?n="+encodeURIComponent(n)+"&p="+encodeURIComponent(p));
    xhr.timeout = 180000;
    xhr.onload = function(){
        if(xhr.status===200){
            const txt = xhr.responseText;
            const parsed = parseTimesFromText(txt);
            
            // Actualizar tabla de tiempos
            let tbody = document.getElementById("timesTable");
            if(parsed.t1 !== null || parsed.t2 !== null){
                let a = parsed.t1 !== null ? parsed.t1 : "";
                let b = parsed.t2 !== null ? parsed.t2 : "";
                let diff = (a !== "" && b !== "") ? Math.abs(a - b) : "";
                tbody.innerHTML = "<tr><td>"+a+"</td><td>"+b+"</td><td>"+diff+"</td></tr>";
                status.textContent = "Cálculo terminado - Recibiendo valores...";
            } else {
                tbody.innerHTML = "<tr><td colspan='3'>No se recibieron tiempos</td></tr>";
                status.textContent = "Cálculo terminado (sin tiempos)";
            }
            
            // Esperar un poco más y luego obtener valores con reintentos
            setTimeout(function(){ fetchValuesWithRetry(expectedPoints, 0); }, 500);
        } else {
            status.textContent = "Error: " + xhr.status;
            document.getElementById("timesTable").innerHTML = "<tr><td colspan='3'>Error</td></tr>";
        }
    };
    xhr.onerror = function(){ status.textContent = "Request error"; };
    xhr.ontimeout = function(){ status.textContent = "Timeout"; };
    xhr.send();
}

function fetchValuesWithRetry(expectedPoints, attempt){
    let maxAttempts = 15; // Máximo 15 intentos
    let xhr = new XMLHttpRequest();
    xhr.open("GET", "/getvalues");
    xhr.timeout = 5000;
    xhr.onload = function(){
        if(xhr.status===200){
            try {
                const data = JSON.parse(xhr.responseText);
                
                if(data.length >= expectedPoints || attempt >= maxAttempts - 1){
                    // Tenemos todos los puntos o llegamos al límite de intentos
                    updateValuesTable(data);
                    document.getElementById("statusArea").textContent = 
                        "Completado - " + data.length + " de " + expectedPoints + " puntos recibidos";
                } else {
                    // Faltan puntos, reintentar
                    document.getElementById("statusArea").textContent = 
                        "Recibiendo valores... " + data.length + "/" + expectedPoints + " puntos";
                    setTimeout(function(){ fetchValuesWithRetry(expectedPoints, attempt + 1); }, 1000);
                }
            } catch(e) {
                console.error("Error parsing values:", e);
                document.getElementById("statusArea").textContent = "Error al procesar valores";
            }
        } else if(attempt < maxAttempts - 1) {
            // Reintentar si hubo error
            setTimeout(function(){ fetchValuesWithRetry(expectedPoints, attempt + 1); }, 1000);
        }
    };
    xhr.onerror = function(){ 
        if(attempt < maxAttempts - 1) {
            setTimeout(function(){ fetchValuesWithRetry(expectedPoints, attempt + 1); }, 1000);
        }
    };
    xhr.send();
}

function updateValuesTable(data){
    let tbody = document.getElementById("valuesTable");
    if(data.length === 0){
        tbody.innerHTML = "<tr><td colspan='4'>No hay datos disponibles</td></tr>";
        return;
    }
    
    let html = "";
    for(let i = 0; i < data.length; i++){
        let point = data[i];
        let diff = Math.abs(point.y1 - point.y2).toExponential(6);
        html += "<tr>";
        html += "<td>" + point.x.toFixed(6) + "</td>";
        html += "<td>" + point.y1.toExponential(8) + "</td>";
        html += "<td>" + point.y2.toExponential(8) + "</td>";
        html += "<td>" + diff + "</td>";
        html += "</tr>";
    }
    tbody.innerHTML = html;
    
    // Actualizar gráfico
    updateChart(data);
}

// Redibujar gráfico al cambiar tamaño de ventana
window.addEventListener('resize', drawChart);

// Dibujar gráfico inicial al cargar
window.onload = function(){
    drawChart();
};
</script>
</div>
</body>
</html>
"""
    return html

# =============================================
# Server handlers
# =============================================
def serve_sinc(sreq):
    up = fetch_uri_params(sreq)
    if "n" not in up or "p" not in up:
        return "HTTP/1.1 400 Bad Request\r\n\r\nMissing parameters 'n' or 'p'"
    try:
        n = int(up["n"])
        p = int(up["p"])
    except:
        return "HTTP/1.1 400 Bad Request\r\n\r\nInvalid parameters"
    if n < 10 or n > 1000 or p < 10 or p > 300:
        return "HTTP/1.1 400 Bad Request\r\n\r\nParameters out of range"

    resp = send_sinc_request(n, p, timeout_ms=180000)
    if resp is None:
        return "HTTP/1.1 500 Internal Server Error\r\n\r\nNo response from RP2040"
    return "HTTP/1.1 200 OK\r\n\r\n" + resp

def serve_values():
    """Envía los valores calculados en formato JSON, ordenados por índice"""
    with lkPoints:
        points = list(calculated_points)
    
    # Ordenar por índice si está disponible
    if points and "idx" in points[0] and points[0]["idx"] != -1:
        points.sort(key=lambda p: p["idx"])
    
    try:
        json_data = ujson.dumps(points)
        return "HTTP/1.1 200 OK\r\nContent-Type: application/json\r\n\r\n" + json_data
    except Exception as e:
        print("Error serializing JSON:", e)
        return "HTTP/1.1 500 Internal Server Error\r\n\r\nError creating JSON"

def serve_debug():
    with lkLines:
        lines = list(incoming_lines[-MAX_DEBUG_LINES:])
    body = "HTTP/1.1 200 OK\r\nContent-Type: text/plain\r\n\r\n"
    body += "Last {} lines from RP2040 (most recent last):\n\n".format(len(lines))
    body += "\n".join(lines)
    return body

def serve_web():
    try:
        cnn, addr = s_web.accept()
        cnn.settimeout(3)
        req = cnn.recv(4096)
        if not req:
            cnn.close()
            return
        try:
            sreq = req.decode("utf-8")
        except:
            sreq = str(req)
        
        if not sreq.startswith("GET "):
            cnn.send(b"HTTP/1.1 400 Bad Request\r\n\r\nInvalid method")
            cnn.close()
            return
        
        path = sreq[4:sreq.find(" ", 5)]
        
        if path.startswith("/sinc") or path.startswith("/?"):
            payload = serve_sinc(path)
        elif path == "/getvalues":
            payload = serve_values()
        elif path == "/debug":
            payload = serve_debug()
        elif path == "/":
            payload = webpage()
        else:
            payload = "HTTP/1.1 404 Not Found\r\n\r\nNot found"
        
        try:
            cnn.send(payload)
        except Exception as e:
            print("Error sending payload:", e)
        cnn.close()
    except Exception as e:
        try:
            cnn.close()
        except:
            pass

# =============================================
# Main
# =============================================
def main():
    setupUART()
    setupWiFi()
    ok = do_handshake()
    if not ok:
        raise Exception("Failed to communicate with RP2040 (no PONG)")
    _thread.start_new_thread(uart_reader_thread, (None,))
    setupSockets()
    print("System ready. Waiting for HTTP connections...")
    while True:
        serve_web()

if __name__ == "__main__":
    main()